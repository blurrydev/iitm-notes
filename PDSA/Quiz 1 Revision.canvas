{
	"nodes":[
		{"type":"text","text":"Sorting","id":"136611ece51a1635","x":40,"y":-120,"width":110,"height":60},
		{"type":"text","text":"Searching","id":"477b30d355deefc5","x":-180,"y":-120,"width":133,"height":60},
		{"type":"text","text":"Algorithms","id":"8a7377082968ee61","x":-80,"y":-260,"width":140,"height":60,"color":"3"},
		{"type":"text","text":"#### Quick Sort\n[[Week 3#^d3d8fe]]\n\nQuick sort is a divide and conquer algorithm that partitions a list into two sub-lists based on a pivot element. It then recursively sorts the sub-lists until the entire list is sorted.\n\nExample:\n\nSuppose we have an array [5, 2, 9, 3, 6, 8]. We choose the pivot element as 5. The algorithm then partitions the array into [2, 3] and [9, 6, 8]. We then choose the pivot element as 9 and partition the sub-list [9, 6, 8] into [6] and [8]. We now have the sorted array [2, 3, 5, 6, 8, 9].\n\nWorst Case Time Complexity: O(n^2)\n\nStable or Not Stable: Not Stable","id":"b8cb6e43edd5eef2","x":440,"y":1500,"width":760,"height":540},
		{"type":"text","text":"#### Merge Sort\n[[Week 2#^756b56]]\n\nMerge sort is a divide and conquer algorithm that divides a list into sub-lists until each sub-list contains only one element. It then repeatedly merges the sub-lists in a sorted manner until the entire list is sorted.\n\nExample:\n\nSuppose we have an array [5, 2, 9, 3, 6, 8]. The algorithm divides the array into [5, 2, 9] and [3, 6, 8]. It then divides the sub-lists into [5], [2], [9], [3], [6], and [8]. It merges the sub-lists into [2, 5, 9] and [3, 6, 8]. It then merges the sub-lists again into the sorted array [2, 3, 5, 6, 8, 9].\n\nWorst Case Time Complexity: O(n log n)\n\nStable or Not Stable: Stable","id":"7ae55cbca70fc9c7","x":440,"y":820,"width":760,"height":550},
		{"type":"text","text":"#### Selection sort\n[[Week 2#^46e713]]\n\nSelection sort is a simple sorting algorithm that repeatedly finds the minimum element from an unsorted sub-list and swaps it with the first element. It then moves the sub-list boundary one element to the right and repeats the process until the entire array is sorted.\n\nExample:\n\nSuppose we have an array [5, 2, 9, 3, 6, 8]. The algorithm selects the minimum element (2) and swaps it with the first element (5). It then selects the minimum element (3) from the remaining sub-list and swaps it with the second element (5). The algorithm repeats this process until the entire array is sorted.\n\nWorst Case Time Complexity: O(n^2)\n\nStable or Not Stable: Not Stable","id":"399add341e832dcb","x":440,"y":180,"width":760,"height":500},
		{"type":"text","text":"#### Insertion Sort\n[[Week 2#^5a4be1]]\n\nInsertion sort is a simple sorting algorithm that builds the final sorted array one item at a time. It iterates through an input list, comparing each item with the previous items and swapping them until it reaches the correct position.\n\nExample:\n\nSuppose we have an array [5, 2, 9, 3, 6, 8]. The algorithm compares the second element (2) with the first element (5) and swaps them. It then compares the third element (9) with the second element (5), swaps them, and compares the second element (5) with the first element (2) and swaps them again. The algorithm repeats this process until the entire array is sorted.\n\nWorst Case Time Complexity: O(n^2)\n\nStable or Not Stable: Stable","id":"7711e7caf7cc9535","x":440,"y":-530,"width":660,"height":660},
		{"type":"text","text":"#### Na√Øve Search\n[[Week 2#^83f669]]\n\nNaive search is a simple searching algorithm that iterates through an input list and compares each element with the target element until it finds a match. It is called \"naive\" because it does not use any optimization techniques to speed up the search process.\n\nExample:\n\nSuppose we have an array [5, 2, 9, 3, 6, 8] and we want to search for the element 6. The algorithm starts from the first element (5), compares it with 6, and moves to the next element (2). It continues this process until it finds the target element (6).\n\nWorst Case Time Complexity: O(n)","id":"c00a5065d4e83708","x":-920,"y":60,"width":584,"height":580},
		{"type":"text","text":"#### Binary Search\n[[Week 2#^5b7ed4]]\n\nBinary search is a searching algorithm that works by dividing an input list into two sub-lists and searching the target element in the appropriate sub-list. It assumes that the input list is sorted and uses this property to reduce the search space in each iteration.\n\nExample:\n\nSuppose we have a sorted array [2, 3, 5, 6, 8, 9] and we want to search for the element 6. The algorithm first compares the target element with the middle element (5) and determines that it needs to search in the right sub-list. It then divides the right sub-list [6, 8, 9] into two sub-lists and searches in the appropriate sub-list. It repeats this process until it finds the target element.\n\nWorst Case Time Complexity: O(log n)\n\nNote: Binary search only works for sorted arrays and not for unsorted arrays.","id":"fea1797753011d8f","x":-950,"y":780,"width":644,"height":695}
	],
	"edges":[
		{"id":"b9ac1cae92705fa4","fromNode":"8a7377082968ee61","fromSide":"bottom","toNode":"477b30d355deefc5","toSide":"top"},
		{"id":"1e0b4963cd30656d","fromNode":"8a7377082968ee61","fromSide":"bottom","toNode":"136611ece51a1635","toSide":"top"},
		{"id":"59e9b386a2f63351","fromNode":"136611ece51a1635","fromSide":"bottom","toNode":"7711e7caf7cc9535","toSide":"left"},
		{"id":"ed933d54df17ae2a","fromNode":"136611ece51a1635","fromSide":"bottom","toNode":"399add341e832dcb","toSide":"left"},
		{"id":"3b337ea1e813a054","fromNode":"136611ece51a1635","fromSide":"bottom","toNode":"7ae55cbca70fc9c7","toSide":"left"},
		{"id":"72222a6db63db396","fromNode":"136611ece51a1635","fromSide":"bottom","toNode":"b8cb6e43edd5eef2","toSide":"left"},
		{"id":"20e01790322a9262","fromNode":"477b30d355deefc5","fromSide":"bottom","toNode":"c00a5065d4e83708","toSide":"right"},
		{"id":"43c901487ca79a07","fromNode":"477b30d355deefc5","fromSide":"bottom","toNode":"fea1797753011d8f","toSide":"right"}
	]
}